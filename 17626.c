/*
    No: 17626
    Title: Four Squares
    Problem:
        라그랑주는 1770년에 모든 자연수는 넷 혹은 그 이하의 제곱수의 합으로 표현할 수 있다고 증명하였다. 
        어떤 자연수는 복수의 방법으로 표현된다. 
        예를 들면, 26은 52과 12의 합이다; 또한 42 + 32 + 12으로 표현할 수도 있다. 
        역사적으로 암산의 명수들에게 공통적으로 주어지는 문제가 바로 자연수를 넷 혹은 그 이하의 제곱수 합으로 나타내라는 것이었다. 
        1900년대 초반에 한 암산가가 15663 = 1252 + 62 + 12 + 12라는 해를 구하는데 8초가 걸렸다는 보고가 있다. 
        좀 더 어려운 문제에 대해서는 56초가 걸렸다: 11339 = 1052 + 152 + 82 + 52.
        자연수 n이 주어질 때, n을 최소 개수의 제곱수 합으로 표현하는 컴퓨터 프로그램을 작성하시오.
    Input:
        입력은 표준입력을 사용한다. 입력은 자연수 n을 포함하는 한 줄로 구성된다. 여기서, 1 ≤ n ≤ 50,000이다. 
    Output:
        출력은 표준출력을 사용한다. 합이 n과 같게 되는 제곱수들의 최소 개수를 한 줄에 출력한다.
    Lang:
        C11
    Explanation:
        브루트포스 알고리즘(전체탐색)이 필요한 문제이다. 전체탐색이 필요한 문제인 만큼 수학적으로 불필요한 탐색 범위는 제외시키는 것이 중요하다.
        라그랑주의 "네 제곱수 정리"는 어떤 임의의 수 X는 임의의 n가지 수(0<n<5, n은 자연수)들을 각각 제곱한 뒤 합한 식으로 표현할 수 있다는 정리이다.
        X = a^2 + b^2 + c^2 + d^2 (a,b,c,d >= 0 이며 a,b,c,d는 정수)
        위 식으로 어떤 임의의 수를 표현한다고 할때 a,b,c,d는 제곱해서 전체의 합이 X가 되기 때문에 a,b,c,d는
        floor(X^0.5)보다 작거나 같게된다 (식 내의 모든 항들은 정수로 이루어져있기 때문에 올림을 할 필요가 없다.) 그리고 a,b,c,d를 왼쪽부터 오른쪽으로 큰수에서 작은수로 정렬할 경우,
        a >= b >= c >= d 이 성립하게 된다.

        위와 같은 특성으로 우리는 탐색 범위를 아래와 같이 좁힐 수 있다.
        아래 범위 내에서 반복문을 돌리며 각 값을 제곱한 후의 총합이
        주어진 X와 동일한지 검사하고 그러한 경우의 수들 중 X를 표현하기 위해 사용된 자리수가 가장 적은 경우를 출력하면된다.
        X = (입력으로 주어진 수)
        a = floor(X^0.5)
        a >= b >= c >= d

*/

#include<stdio.h>
#include<math.h>

int result = 9999; // 최소 자리수를 저장하기 위한 변수

void fs(int n) { // 검사 함수
    int X=0,a,b,c,d;
    for(a=pow(n,0.5);a>-1;a--) { // a의 초기값을 (int)n^0.5로 설정하고 0까지 1씩 감소시키며 검사 (n=주어진수)
        X+=a*a; // 임시 합산가 변수에 a^2을 더함
        if(X==n) { // 1보다 자리수가 적은 경우가 없으므로 자릿수를 저장하고 즉시 종료
            result = 1;
            return;
        }
        else if(a!=0) { // a가 0이 아닐경우, 다음 자릿수를 찾는다
            for(b=a;b>-1;b--) { // b를 a로 초기화하고 0까지 1씩 감소시키며 검사
                X+=b*b; // 임시 합산가 변수에 b^2을 더함
                if(X==n&&result>2) result = 2; // 최소자릿수가 맞는지 검사 후, 참이면 자릿수 저장
                else if(b!=0) { // b가 0이 아닐경우, 다음 자릿수를 찾는다
                    for(c=b;c>-1;c--) { // c를 b로 초기화하고 0까지 1씩 감소시키며 검사
                        X+=c*c; // 임시 합산가 변수에 c^2을 더함
                        if(X==n&&result>3) result = 3; // 최소자릿수가 맞는지 검사 후, 참이면 자릿수 저장
                        else if(c!=0) { // c가 0이 아닐경우, 다음 자릿수를 찾는다
                            for(d=c;d>-1;d--) { // d를 c로 초기화하고 0까지 1씩 감소시키며 검사
                                X+=d*d; // 임시 합산가 변수에 d^2을 더함
                                if(X==n&&result>4) result = 4; // 최소자릿수가 맞는지 검사 후, 참이면 자릿수 저장
                                X-=d*d; // 다음 수를 검사하기 위해 임시 합산가 초기화
                            }
                        } 
                        X-=c*c; // 다음 수를 검사하기 위해 임시 합산가 초기화
                    }
                }
                X-=b*b; // 다음 수를 검사하기 위해 임시 합산가 초기화
            }
        }
        X-=a*a; // 다음 수를 검사하기 위해 임시 합산가 초기화
    }
}

int main() {
    int N;
    scanf("%d",&N);
    fs(N);
    printf("%d",result);
    return 0;
}